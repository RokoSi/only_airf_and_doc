import logging
import os
from datetime import datetime
from pprint import pprint

from airflow import DAG
from airflow.operators.python import PythonOperator, BranchPythonOperator
from airflow.providers.http.operators.http import SimpleHttpOperator
from airflow.providers.postgres.operators.postgres import PostgresOperator
from validators import validator_email, validator_pass

log_dir = os.path.join(os.getcwd(), "logs")
log_file = os.path.join(log_dir, "logfile.log")
os.makedirs(log_dir, exist_ok=True)
logging.basicConfig(
    filename=log_file,
    filemode="a",
    encoding="utf-8",
    level=logging.INFO,
    format="'%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    datefmt="%d/%m/%Y %I:%M:%S %p",
)
log = logging.getLogger(__name__)


def validate_data_users(ti):
    users = ti.xcom_pull(task_ids="get_request")
    if not users:
        raise ValueError("Нет данных для обработки")
    users_db = []
    for user in users:
        if validator_email(user["email"]):
            valid_password = validator_pass(user["login"]["password"])
            user["valid"] = valid_password
            users_db.append(user)
        else:
            raise Exception("невалидный email")

    ti.xcom_push(key="validated_users", value=users_db)


check_tables_query = """
SELECT COUNT(*) FROM pg_catalog.pg_tables
WHERE schemaname NOT IN ('pg_catalog', 'information_schema');
"""

ddl: str = """

    CREATE table if not EXISTS users(
    user_id      INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    gender       VARCHAR(255),
    name_title   VARCHAR(255),
    name_first   VARCHAR(255),
    name_last    VARCHAR(255),
    age 		 INT,
    nat          VARCHAR(255),
    created_dttm TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_dttm TIMESTAMP DEFAULT CURRENT_TIMESTAMP
   );

-- Создание таблицы contact_details
CREATE table if not EXISTS contact_details(
    user_id      INT NOT NULL,
    phone        VARCHAR(255),
    cell         VARCHAR(255),
    created_dttm TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_dttm TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    FOREIGN KEY (user_id) REFERENCES users(user_id)
);

-- Создание таблицы media_data
CREATE table if not EXISTS media_data(
    user_id         INT NOT NULL,
    picture         VARCHAR(255),
    created_dttm    TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_dttm    TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    FOREIGN KEY (user_id) REFERENCES users(user_id)
);
CREATE table if not EXISTS registration_data(
    user_id             INT NOT NULL,
    email               VARCHAR(255),
    username            VARCHAR(255),
    password            VARCHAR(255),
    password_md5        VARCHAR(255),
    password_validation BOOLEAN,
    created_dttm        TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_dttm        TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    FOREIGN KEY (user_id) REFERENCES users(user_id)
);

-- Создание таблицы cities
CREATE table if not EXISTS cities(
    city_id 	 INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    city 		 VARCHAR(255),
    state 		 VARCHAR(255),
    country 	 VARCHAR(255),
    created_dttm TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_dttm TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT unique_city_state_country UNIQUE (city,state,country)

);

-- Создание таблицы locations
CREATE table if not EXISTS locations(
    user_id       INT NOT NULL,
    city_id       INT NOT NULL,
    street_name   VARCHAR(255),
    street_number INT,
    postcode      VARCHAR(255),
    latitude      FLOAT,
    longitude     FLOAT,
    created_dttm  TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_dttm  TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    FOREIGN KEY (user_id) REFERENCES users(user_id),
    FOREIGN KEY (city_id) REFERENCES cities(city_id)
);"""


def save_to_postgres(ti):
    users = ti.xcom_pull(task_ids="validator_data_users", key="validated_users")
    if not users:
        raise ValueError("Нет данных для вставки в базу данных")

    from airflow.providers.postgres.hooks.postgres import PostgresHook

    pg_hook = PostgresHook(postgres_conn_id='postgres_connection')
    conn = pg_hook.get_conn()
    cursor = conn.cursor()

    for user in users:
        pprint(user)

        # Вставка в таблицу users
        cursor.execute("""
            INSERT INTO users (gender, name_title, name_first, name_last, age, nat)
            VALUES (%s, %s, %s, %s, %s, %s)
            RETURNING user_id
        """, (
            user['gender'], user['name']['title'], user['name']['first'], user['name']['last'], user['dob']['age'], user['nat']
        ))
        user_id = cursor.fetchone()[0]

        # Вставка в таблицу cities
        cursor.execute("""
            INSERT INTO cities (city, state, country)
            VALUES (%s, %s, %s)
            ON CONFLICT (city, state, country) DO NOTHING
            RETURNING city_id
        """, (
            user['location']['city'], user['location']['state'], user['location']['country']
        ))
        city_id = cursor.fetchone()[0] if cursor.rowcount > 0 else None

        # Вставка в таблицу contact_details
        cursor.execute("""
            INSERT INTO contact_details (user_id, phone, cell)
            VALUES (%s, %s, %s)
        """, (
            user_id, user['phone'], user['cell']
        ))

        # Вставка в таблицу media_data
        cursor.execute("""
            INSERT INTO media_data (user_id, picture)
            VALUES (%s, %s)
        """, (
            user_id, user['picture']['large']
        ))

        # Вставка в таблицу registration_data
        cursor.execute("""
            INSERT INTO registration_data (user_id, email, username, password, password_md5, password_validation)
            VALUES (%s, %s, %s, %s, %s, %s)
        """, (
            user_id, user['email'], user['login']['username'], user['login']['password'], user['login']['md5'], user['valid']
        ))

        # Вставка в таблицу locations
        cursor.execute("""
            INSERT INTO locations (user_id, city_id, street_name, street_number, postcode, latitude, longitude)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, (
            user_id, city_id, user['location']['street']['name'], user['location']['street']['number'], user['location']['postcode'],
            user['location']['coordinates']['latitude'], user['location']['coordinates']['longitude']
        ))

    conn.commit()
    cursor.close()




def decide_next_task(**kwargs):
    ti = kwargs["ti"]
    result = ti.xcom_pull(task_ids="check_tables")
    log.info(f"Result from check_tables: {result}")
    if result and result[0][0] == 0:
        log.info("No tables found, returning create_tables")
        return "create_tables"
    log.info("Tables exist, returning fill_tables")
    return "fill_tables"


args = {
    "owner": "Chernyshev-Pridvorov",
    "depends_on_past": False,
    "start_date": datetime(2023, 8, 5),
    "retries": 1,
    # 'provide_context': True
}
with DAG(
    "test_de_airf",
    description="test1",
    schedule_interval="*/1 * * * *",
    catchup=False,  # TODO
    default_args=args,
) as dag:
    get_request = SimpleHttpOperator(
        task_id="get_request",
        http_conn_id="http_default",
        endpoint="",
        method="GET",
        response_filter=lambda response: response.json().get("results", []),
        log_response=True,
        dag=dag,
    )

    validator_data_users = PythonOperator(
        task_id="validator_data_users",
        python_callable=validate_data_users,
    )

    # branch_op = BranchPythonOperator(
    #     task_id="decide_next_task",
    #     python_callable=decide_next_task,
    #     provide_context=True,
    #     dag=dag,
    # )

    check_tables = PostgresOperator(
        task_id="check_tables",
        postgres_conn_id="postgres_connection",
        sql=check_tables_query,
        dag=dag,
    )

    create_tables = PostgresOperator(
        task_id="create_tables",
        postgres_conn_id="postgres_connection",
        sql=ddl,
        dag=dag,
    )

    # fill_tables = PostgresOperator(
    #     task_id="fill_tables",
    #     postgres_conn_id="postgres_connection",
    #     sql="""{% for user in ti.xcom_pull(task_ids='validator_data_users', key='validated_users') %}
    #     WITH ins AS (
    #         INSERT INTO users (gender, name_title, name_first, name_last, age, nat)
    #         VALUES (%s, %s, %s, %s, %s, %s)
    #         RETURNING user_id
    #     ),
    #     ins_city AS (
    #         INSERT INTO cities (city, state, country)
    #         VALUES (%s, %s, %s)
    #         ON CONFLICT (city, state, country) DO NOTHING
    #         RETURNING city_id
    #     )
    #     INSERT INTO contact_details (user_id, phone, cell)
    #     VALUES ((SELECT user_id FROM ins),%s,%s);
    #
    #     INSERT INTO media_data (user_id, picture)
    #     VALUES ((SELECT user_id FROM ins), %s);
    #
    #     INSERT INTO registration_data (user_id, email, username, password, password_md5, password_validation)
    #     VALUES ((SELECT user_id FROM ins), %s, %s, %s, %s, %s);
    #
    #     INSERT INTO locations (user_id, city_id, street_name, street_number, postcode, latitude, longitude)
    #     VALUES ((SELECT user_id FROM ins), (SELECT city_id FROM ins_city), %s, %s, %s, %s, %s);
    #     {% endfor %}
    #     """,
    #     dag=dag,
    # )
    save_data = PythonOperator(
        task_id="save_data_to_postgres",
        python_callable=save_to_postgres,
    )

get_request >> validator_data_users >> create_tables >> save_data

