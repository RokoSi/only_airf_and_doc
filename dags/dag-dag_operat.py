import logging
import os
from datetime import datetime

from airflow import DAG
from airflow.operators.python import PythonOperator
from airflow.providers.http.operators.http import SimpleHttpOperator
from airflow.providers.postgres.operators.postgres import PostgresOperator

from json_parsing import pars_user
from validators import validator_email, validator_pass

log_dir = os.path.join(os.getcwd(), "logs")
log_file = os.path.join(log_dir, "logfile.log")
os.makedirs(log_dir, exist_ok=True)
logging.basicConfig(
    filename=log_file,
    filemode="a",
    encoding="utf-8",
    level=logging.INFO,
    format="'%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    datefmt="%d/%m/%Y %I:%M:%S %p",
)
log = logging.getLogger(__name__)



args = {
    "owner": "Chernyshev-Pridvorov",
    "depends_on_past": False,
    "start_date": datetime(2023, 8, 5),
    "retries": 1,
    'provide_context': True
}


def validate_data_users(ti):
    users = ti.xcom_pull(task_ids="get_request")
    if not users:
        raise ValueError("Нет данных для обработки")
    users_db = []
    for user in users:
        if validator_email(user["email"]):
            valid_password = validator_pass(user["login"]["password"])
            user["valid"] = valid_password
            users_db.append(user)
        else:
            raise Exception("невалидный email")

    ti.xcom_push(key="validated_users", value=users_db)


check_tables_query = """
SELECT COUNT(*) FROM pg_catalog.pg_tables
WHERE schemaname NOT IN ('pg_catalog', 'information_schema');
"""

ddl: str = """

    CREATE table if not EXISTS users(
    user_id      INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    gender       VARCHAR(255),
    name_title   VARCHAR(255),
    name_first   VARCHAR(255),
    name_last    VARCHAR(255),
    age 		 INT,
    nat          VARCHAR(255),
    created_dttm TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_dttm TIMESTAMP DEFAULT CURRENT_TIMESTAMP
   );

-- Создание таблицы contact_details
CREATE table if not EXISTS contact_details(
    user_id      INT NOT NULL,
    phone        VARCHAR(255),
    cell         VARCHAR(255),
    created_dttm TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_dttm TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    FOREIGN KEY (user_id) REFERENCES users(user_id)
);

-- Создание таблицы media_data
CREATE table if not EXISTS media_data(
    user_id         INT NOT NULL,
    picture         VARCHAR(255),
    created_dttm    TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_dttm    TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    FOREIGN KEY (user_id) REFERENCES users(user_id)
);
CREATE table if not EXISTS registration_data(
    user_id             INT NOT NULL,
    email               VARCHAR(255),
    username            VARCHAR(255),
    password            VARCHAR(255),
    password_md5        VARCHAR(255),
    password_validation BOOLEAN,
    created_dttm        TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_dttm        TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    FOREIGN KEY (user_id) REFERENCES users(user_id)
);

-- Создание таблицы cities
CREATE table if not EXISTS cities(
    city_id 	 INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    city 		 VARCHAR(255),
    state 		 VARCHAR(255),
    country 	 VARCHAR(255),
    created_dttm TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_dttm TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT unique_city_state_country UNIQUE (city,state,country)

);

-- Создание таблицы locations
CREATE table if not EXISTS locations(
    user_id       INT NOT NULL,
    city_id       INT NOT NULL,
    street_name   VARCHAR(255),
    street_number INT,
    postcode      VARCHAR(255),
    latitude      FLOAT,
    longitude     FLOAT,
    created_dttm  TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_dttm  TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    FOREIGN KEY (user_id) REFERENCES users(user_id),
    FOREIGN KEY (city_id) REFERENCES cities(city_id)
);"""


def decide_next_task(**kwargs):
    ti = kwargs["ti"]
    result = ti.xcom_pull(task_ids="check_tables")
    log.info(f"Result from check_tables: {result}")
    if result and result[0][0] == 0:
        log.info("No tables found, returning create_tables")
        return "create_tables"
    log.info("Tables exist, returning fill_tables")
    return "fill_tables"


def form_sql_instert(**kwargs):
    ti = kwargs["ti"]

    result = ti.xcom_pull(task_ids="validator_data_users", key="validated_users")
    ti.log.info("Полученные данные: %s", result)
    ti.log.info("person = %s", type(result))

    sql = """WITH ins AS (
                INSERT INTO users (gender, name_title, name_first, name_last, age, nat)
                VALUES (%s, %s, %s, %s, %s, %(s)
                RETURNING user_id
            ),
            ins_city AS (
                INSERT INTO cities (city, state, country)
                VALUES %s, %s, %s)
                ON CONFLICT (city, state, country) DO NOTHING
                RETURNING city_id
            )
            INSERT INTO contact_details (user_id, phone, cell)
            VALUES ((SELECT user_id FROM ins),%s,%s);

            INSERT INTO media_data (user_id, picture)
            VALUES ((SELECT user_id FROM ins), %s);

            INSERT INTO registration_data (user_id, email, username, password, password_md5, password_validation)
            VALUES ((SELECT user_id FROM ins), %s, %s, %s, %s,
             %(password_validation)s);

            INSERT INTO locations (user_id, city_id, street_name, street_number, postcode, latitude, longitude)
            VALUES ((SELECT user_id FROM ins), (SELECT city_id FROM ins_city), %s, %s,
             %s, %(s, %s);"""
    queries = []
    user = pars_user(result)
    ti.log.info("user = ", user)
    param = (user[0].gender, user[0].name.title, user[0].name.first, user[0].name.last, user[0].registered.age,
                 user[0].nat, user[0].location.city, user[0].location.state, user[0].location.country, user[0].phone,
                 user[0].cell, user[0].picture, user[0].email, user[0].username,
                 user[0].password, user[0].password_md5,
                 user[0].password_validation, user[0].location.street, user[0].location.street_number,
                 user[0].location.postcode, user[0].location.latitude, user[0].location.longitude)
    log.info(sql % tuple(param))
    query = sql % tuple(param)
    queries.append(query)
    ti.xcom_push(key="sql_queries", value=queries)


with DAG(
        "test_de",
        description="test1",
        schedule_interval="*/1 * * * *",
        catchup=False,  # TODO
        default_args=args,
) as dag:
    get_request = SimpleHttpOperator(
        task_id="get_request",
        http_conn_id="http_default",
        endpoint="",
        method="GET",
        response_filter=lambda response: response.json().get("results", []),
        log_response=True,
        dag=dag,
    )

    validator_data_users = PythonOperator(
        task_id="validator_data_users",
        python_callable=validate_data_users,
    )

    check_tables = PostgresOperator(
        task_id="check_tables",
        postgres_conn_id="postgres_connection",
        sql=check_tables_query,
        dag=dag,
    )

    # Задача для создания таблиц
    create_tables = PostgresOperator(
        task_id="create_tables",
        postgres_conn_id="postgres_connection",
        sql=ddl,
        dag=dag,
    )

    execute_sql = PythonOperator(
        task_id="execute_sql",
        python_callable=form_sql_instert,
        provide_context=True,
        dag=dag,
    )

    execute_insert_queries = PostgresOperator(
        task_id="execute_insert_queries",
        postgres_conn_id="postgres_connection",
        sql="{{ ti.xcom_pull(task_ids='form_sql_instert', key='sql_queries') }}",
        dag=dag,
    )

# # fill_tables = PostgresOperator(
#      task_id="fill_tables",
#      postgres_conn_id="postgres_connection",
#      sql="""{% for user in ti.xcom_pull(task_ids='validator_data_users', key='validated_users') %}
#      WITH ins AS (
#          INSERT INTO users (gender, name_title, name_first, name_last, age, nat)
#          VALUES (%(gender)s, %(name_title)s, %(name_first)s, %(name_last)s, %(age)s, %(nat)s)
#          RETURNING user_id
#      ),
#      ins_city AS (
#          INSERT INTO cities (city, state, country)
#          VALUES (%(city)s, %(state)s, %(country)s)
#          ON CONFLICT (city, state, country) DO NOTHING
#          RETURNING city_id
#      )
#      INSERT INTO contact_details (user_id, phone, cell)
#      VALUES ((SELECT user_id FROM ins),%(phone)s,%(cell)s);
#
#      INSERT INTO media_data (user_id, picture)
#      VALUES ((SELECT user_id FROM ins), %(picture)s);
#
#      INSERT INTO registration_data (user_id, email, username, password, password_md5, password_validation)
#      VALUES ((SELECT user_id FROM ins), %(email)s, %(username)s, %(password)s, %(password_md5)s,
#       %(password_validation)s);
#
#      INSERT INTO locations (user_id, city_id, street_name, street_number, postcode, latitude, longitude)
#      VALUES ((SELECT user_id FROM ins), (SELECT city_id FROM ins_city), %(street_name)s, %(street_number)s,
#       %(postcode)s, %(latitude)s, %(longitude)s);
#      {% endfor %}
#      """,
#      parameters={'gender': 'user.gender', 'name_title': 'user.name.title', 'name_first': 'user.name.first',
#                  'age': 'user.dob.age', 'nat': 'user.nat', 'city': 'user.location.city',
#                  'state': 'user.location.state', 'country': 'user.location.country'},
#      dag=dag,
# )

get_request >> validator_data_users >>check_tables >> create_tables >> execute_sql >> execute_insert_queries
# >> fill_tables

# get_request >> validator_data_users
# validator_data_users >> check_tables
# check_tables >> branch_op
# branch_op >> create_tables >> fill_tables
# branch_op >> fill_tables
